comment ~

ВЫХОД-5 (Задача_1, вспомогательный модуль)

Написать программу из двух модулей. 

В головном модуле описать двойное слово  X (содержимое которого
трактуется как число без знака) и байт Res (содержимое которого
трактуется как число со знаком).  

Во вспомогательном  модуле описать  общедоступную процедуру 
Power2(X,Res) со стандартными соглашениями о связях  (stdcall).
Параметр  X передаётся в процедуру по значению, Res – по ссылке.
Процедура Power2 выполняет проверку 32-битной беззнаковой величины Х:
является ли она степенью двойки, т.е. существует ли такое  k: 
от 0 до 31, что X=2^k. Если да, то процедура записывает в байт Res
показатель k найденной степени двойки, иначе – записывает в байт Res
 -1 (минус!). В процессе своей работы процедура не использует команды
умножения и деления. 

Головной модуль вводит значение переменной Х,  после чего обращается
к внешней процедуре Power2(X,Res)  для проверки числа X.  Затем 
головной модуль выводит в окно консоли полученный в Res ответ. 
На этом работа двухмодульной программы 
завершается.

Подсказка: в двоичном представлении степень двойки выглядит как 
000…010…00, начальная или конечная последовательность нулей может
отсутствовать.  При проверке числа Х рекомендуется использовать 
маску вида 000…010…00 с подвижной единицей (передвигающейся от 
одного края маски до другого), а также команду xor для сравнения
битового представления числа Х  с данной маской (командами cmp и 
sub для сравнения с маской - не пользоваться!).  

Тесты:   
1  -> 0,       2  -> 1,      5  -> -1,      256  -> 8,     65536  -> 16,      
65535  > -1,    1048576  > 20,   2147483648   > 31,     4000000000  > -1   

~

;---------------------------------------------------------------------
;            ВСПОМОГАТЕЛЬНЫЙ МОДУЛЬ (далее ваше решение:)
;---------------------------------------------------------------------
include console.inc
public Power2

.code
Power2 proc
    push EBP
    mov EBP, ESP
    push EAX
    push EBX
    push ECX
    push EDX
    
    mov EBX, [EBP+12]            ; in EBX address Res
    mov ECX, 0
    mov EDX, 1
 @L:
    cmp ECX, 32
    je @no
    mov EAX, [EBP+8]            ; is EAX X
    xor EAX, EDX
    cmp EAX, 0
    je @yes
    shl EDX, 1
    inc ECX
    jmp @L
@yes:
    mov [EBX], CL
    jmp @fin
@no:
    mov ECX, -1
    mov [EBX], CL

@fin:
    pop EDX
    pop ECX
    pop EBX
    pop EAX
    pop EBP
    ret 4*2
Power2 endp
end

;---------------------(конец вашего решения)--------------------------
    

